---
title: 设计模式—开篇
date: 2017-05-26 18:09:45
tags: 
  - 架构
  - 设计模式
categories: 架构
thumbnailImage: design-patterns.png
coverImage: cover.jpg
---

根据《设计模式》一书，设计模式是对定制来解决特定场景下一般设计问题的类和互相通讯对象的描述。

<!--more-->

在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 **Design Patterns - Elements of Reusable Object-Oriented Software**  的书，在书中首次提到了软件开发中设计模式的概念。



设计模式主要基于以下的面向对象设计原则：

* 针对接口编程，而不是针对实现编程
* 优先使用对象组合，而不是继承



### 设计模式的分类

根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software** 中所提到的，总共有 23 种设计模式。这些模式可以分为以下三类：

**创建型**：工厂方法，抽象工厂，单例模式，建造者模式，原型模式；

**结构型**：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式；

**行为型**：策略模式，模板方法，观察者模式，迭代器模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式；



### 设计模式的六大原则

**单一职责原则(SRP)**
> 就一个类而言，应该仅有一个引起它变化的原因。

从这句定义我们很难理解它的含义，通俗讲就是我们不要让一个类承担过多的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到破坏。 



**开发封闭原则(ASD)**

> 软件实体（类、模块、函数等等）应该是可以拓展的，但是不可修改。

开放封闭有两个含义，一个是对于拓展是开放的，另一个是对于修改是封闭的。对于开发来说需求肯定是要变化的，但是新需求一来，我们就要把类重新改一遍这显然是令人头疼的，所以我们设计程序时面对需求的改变要尽可能的保证相对的稳定，尽量用新代码实现拓展来修改需求，而不是通过修改原有的代码来实现。 



**里氏替换原则(LSP)**

> 所有引用基类（父类）的地方必须能透明地使用其子类的对象。

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。 
里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

在使用里氏代换原则时需要注意如下几个问题：
* 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
* 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。



**依赖倒置原则(DIP)**
> 高层模块不应该依赖低层模块，两个都应该依赖于抽象。
> 抽象不应该依赖于细节，细节应该依赖于抽象。



**迪米特原则(LOD)**
> 一个软件实体应当尽可能少地与其他实体发生相互作用。 

也称为最少知识原则。如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 
迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 



**接口隔离原则(ISP)**

> 一个类对另一个类的依赖应该建立在最小的接口上。

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

采用接口隔离原则对接口进行约束时，要注意以下几点：
* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
* 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
* 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。