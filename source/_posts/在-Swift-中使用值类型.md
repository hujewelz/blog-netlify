---
title: ' 在 Swift 中使用值类型'
date: 2018-03-11 16:13:18
tags: Swift
categories: Swift
---



本文是 Swift 系列文章中的第二篇，你可以在[这里](http://jewelz.me/cjt0zq7ce0006620o0nhutb0j/)找到第一篇。按照计划，这篇文章主要介绍一下值类型在 Swift 中的应用。

在讲 Swift 中的值类型之前，我想先复习一下 Objective-C 中的一个知识：为什么在声明 NSString 类型的 property 时要用 copy？我想应该没有人不知道答案吧。在 Swift 中使用字符串可以用 String 类型，而在使用 String 时，就不会出现这个问题了。NSString 在 Foundation 框架中是引用类型，而 String 在 Swift 标准库中是值类型，这可以说是两者最明显的区别了。

<!--more-->

在使用 Swift 时，我们有多种方式来存储结构化的数据，比如结构体，枚举和类。在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分。这可能是标准库中那些类型的特性使然，但是不管从什么方面这个事实都提醒我们 Swift 中结构体有多么重要。许多 Foundation 框架中的类现在有专门针对 Swift 构建的对应结构体类型了。

结构体和类主要有以下的不同：

* 结构体（和枚举）是值类型，而类时引用类型。
* 内存的管理方式不同。结构体可以被直接持有并访问，而类的示例只能通过引用来间接地访问。结构体不会被引用，但是会被复制。也就是所，结构体的持有者是唯一的，但是类的示例却能有很多个持有者。
* 结构体是不能被继承的，而使用类，可以通过继承来共享代码。



## 值类型

我们经常会处理一些需要有明确的生命周期的对象，我们会去初始化它，修改它，最后销毁它。最常见的就是 View 和 View Controller了。一个视图就有着清晰的生命周期：我们会创建它，然后修改它的属于，比如改变背景色，改变位置和大小等，最后当不需要显示时，我们将它从屏幕移除并销毁这个对象。如果我们想修改两个完全不同的视图，我们就需要保证它们是独立的。想比较两个视图，我们只要检查它们是不是指向相同的内存。由于我们比较多是内存地址 ，所有使用引用类型比较合适。

其他一些类型并不需要生命周期。比如一个 URL 在创建后就不会再被更改。更重要的是，它在被摧毁时并不需要进行额外的操作。当我们比较两个 URL 变量时，我们并不关心它们是否指向内存中的同一地址，我们所比较的是它们是否指向同样的 URL。因为我们通过它们的属性来比较 URL，我们将其称为值。在 Objective-C 里，我们用 NSURL 来实现一个不可变的对象。不过在 Swift 中对应的 URL 却是一个结构体。

值永远不会改变，它们具有不可变的特性。这 (在绝大多数情况下) 是一件好事，因为使用不变的数据可以让代码更容易被理解。不可变性也让代码天然地具有线程安全的特性，因为不能改变的东西是可以在线程之间安全地共享的。

Swift 中，结构体是用来构建值类型的。结构体不能通过引用来进行比较，你只能通过它们的属性来比较两个结构体。虽然我们可以用 var 来在结构体中声明可变的变量属性，但是这个可变性只体现在变量本身上，而不是指里面的值。改变一个结构体变量的属性，在概念上来说，和为整个变量赋值一个全新的结构体是等价的。我们总是使用一个新的结构体，并设置被改变的属性值，然后用它替代原来的结构体。这就是为什么我们在修改一个结构体变量的属性时，这个变量必须使用 var 而不能使用 let 的原因，就像下面代码这样：

```swift
let p = Person(name: "Jake", age: 20)
p.age = 23 // Cannot assign to property: 'p' is a 'let' constant
```

结构体只有一个持有者。比如，当我们将结构体变量传递给一个函数时，函数将接收到结构体的复制，它也只能改变它自己的这份复制。这叫做值语义 (value semantics)。而对于对象来说，它们是通过传递引用来工作的，因此类对象会拥有很多持有者，这被叫做引用语义 (reference semantics)。因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。



值类型总是需要复制这件事情听起来可能有点低效，不过，编译器可以帮助我们进行优化，以避免不必要的复制操作。结构体复制的时候发生的是按照字节进行的浅复制。除非结构体中含有类，否则复制时都不需要考虑其中属性的引用计数。当使用 let 来声明结构体时，编译器可以确定之后这个结构体的任何一个字节都不会被改变。另外，和 C++ 中类似的值类型不同，开发者没有办法知道和干预何时会发生结构体的复制。这些简化给了编译器更多的可能性，来排除那些不必要的复制，或者使用传递引用而非值的方式来优化一个常量结构体。

编译器所做的对于值类型的复制优化和值语义类型的写时复制行为并不是一回事儿。写时复制必须由开发者来实现，想要实现写时复制，你需要检测所包含的类是否有共享的引用。

和自动移除不必要的值类型复制不同，写时复制是需要自己实现的。不过编译器会移除那些不必要的“无效”浅复制，以及像是 Array 这样的类型中的代码会执行“智能的”写时复制，两者互为补充，都是对值类型的优化。

如果一个结构体只由其他结构体组成，那编译器可以确保不可变性。同样地，当使用结构体时，编译器也可以生成非常快的代码。举个例子，对一个只含有结构体的数组进行操作的效率，通常要比对一个含有对象的数组进行操作的效率高得多。这是因为结构体通常要更直接：值是直接存储在数组的内存中的。而对象的数组中包含的只是对象的引用。最后，在很多情况下，编译器可以将结构体放到栈上，而不用放在堆里。

![](array_in_stack.png)

## 可变性

所有的竞争问题、死锁问题、并发问题都是由可变变量导致的，如果变量永远不会被更改，那么就不可能产生竞争或者并发问题。这就是为什么大部分专家都会推荐你尽可能地使用不可变的对象，以便写出安全可维护的代码。幸运的是，Swift 可以让我们在写出安全代码的同时，保留直观的可变代码的风格。







## 结构体

## 写时复制



